"use strict";
/*
 * Generated by reqpack (25/12/2018)
 */
const Req = require("@firecubez/req");module.exports = exports = (function(Req){return Req.module("parsle", $$ =>
	$$.depend(
		"parsle$matcher",
		"a module that provides the `Matcher` class"
	) .depend("mirrorprop", "forwards property get/sets"),
	$$ => {

	/*global.clogLevel = 0;
	global.clogState = [];
	global.clog = function(...a) {
		console.log(...a.map(x => ["  ".repeat(global.clogLevel), x, "\n"]).reduce((acc, val) => acc.concat(val), []))
	}
	global.cstart = function() {
		global.clogLevel++;
	}
	global.cend = function() {
		global.clogLevel--;
	}
	global.csave = function() {
		global.clogState.push(global.clogLevel)
	}
	global.cload = function() {
		global.clogLevel = global.clogState.pop();
	}*/
	const mirrorprop = $$.get("mirrorprop", {});
	const Matcher    = $$.get("parsle$matcher", {});

	class Parsle {
		constructor(fn) {
			var $ = new Matcher();
			mirrorprop(this, "input",  $, "input");
			mirrorprop(this, "pos",    $, "pos");
			mirrorprop(this, "error",  $, "error");
			mirrorprop(this, "result", $, "result");
			this.intern = {matcher: $, mf: fn};
		}

		parse(str) {
			var $ = this.intern.matcher;
			this.input = str;
			this.pos = 0;
			this.intern.mf.call($, $);
			return this.result;
		}
	}

	var p = new Parsle($ => {
		$.MATCH(/(?:Mazin)+/)

		$.MATCH(/$/, $.IGNORED);
	});

	var str = "MazinMazinMazin";
	console.log("-----------\n", JSON.stringify(p.parse(str), null, 2));

	return Parsle;

	}
)//*/
})(Req);(function(Req){return Req.module("parsle$matcher", $$ =>
	$$.depend(
		"parsle$parse-error",
		"an Error subclass that gives useful parse info"
	) .depend(
		"line-column",
		"gets line and column information from index"
	),
	$$ => {

	const ParseError = $$.get("parsle$parse-error", {});
	const lineColumn = $$.get("line-column", {});
	const cat = x => x;
	const yes = x => true;

	function Matcher() {
		this.result = []; this.line = 1; this.col = 1;
		this.error = null; this.states = [];
		Object.defineProperty(this, "lc", {
			configurable: false,
			enumerable: false,
			writable: true
		})
		Object.defineProperty(this, "input", {
			configurable: false,
			enumerable: true,
			get: () => this.originalInput,
			set(v) {
				this.originalInput = v;
				this.string = v;
				this.lc = lineColumn(v);
			}
		})
		Object.defineProperty(this, "pos", {
			configurable: false,
			enumerable: true,
			get: () => this._pos,
			set(v) {
				this._pos = v;
				var o     = this.lc.fromIndex(v);
				if(o !== null) {
					this.line = o.line;
					this.col  = o.col;
				} else {
					this.line = "EOF";
					this.col  = "EOF";
				}
			}
		})
		this.input = "";
		this.pos = 0;
	}

	Matcher.prototype.defaultTransform = Matcher.defaultTransform = info => info.match;
	Matcher.prototype.IGNORED = Matcher.IGNORED = Symbol("parsle$Matcher.IGNORED");

	Matcher.prototype.MATCH = function(regex, transform, gate) {
		gate = gate || yes;
		this.MATCH_AHEAD(regex, transform, info => info.match.index === 0 && gate(info));
	}

	Matcher.prototype.MATCH_AHEAD = function(regex, transform, gate) {
		gate      = gate      || yes;
		transform = transform || Matcher.defaultTransform;
		var res   = this.string.match(regex);
		var info  = {
			line: this.line,
			col: this.col,
			pos: this.pos,
			match: res
		};
		if(!res || (info.length = res[0].length, !gate(info))) {
			throw new ParseError(
				"Expected matching " + regex.toString() +
				' but got "' + this.string.slice(0, 5) + '..."',
				this.line, this.col)
		} else {
			if(transform !== Matcher.IGNORED) this.result.push(transform(info));
			this.pos += res[0].length;
			this.string = this.string.slice(res[0].length);
		}
	}

	Matcher.prototype.PUSHSTATE = function() {
		this.states.push({
			result: this.result,
			pos: this.pos,
			string: this.string
		});
	}
	Matcher.prototype.POPSTATE = function() {
		var s       = this.states.pop();
		this.result = s.result,
		this.pos    = s.pos,
		this.string = s.string
	}

	Matcher.prototype.OPTIONAL = function(fn) {
		this.PUSHSTATE();
		try {
			fn();
		} catch(e) {
			this.POPSTATE();
			if(e instanceof ParseError) {
				this.error = e;
				this.result.push(null);
				return false;
			} else {
				throw e;
			}
		}
		this.states.pop();
		return true;
	}
	Matcher.prototype.TRY = function(fn) {
		this.PUSHSTATE();
		var r = this.OPTIONAL(fn);
		this.POPSTATE();
		return r;
	}

	Matcher.prototype.GROUP = function(fn, transform) {
		transform = transform || cat;
		var old = this.result;
		this.result = [];
		fn();
		var r = this.result;
		this.result = old;
		this.result.push(transform(r));
	}
	
	return Matcher;

})//*/
})(Req);(function(Req){return Req.module("parsle$parse-error", null, () => {
	return class ParseError extends Error {
		constructor(msg, line, col) {
			var str = "At line " + line + " col " + col + ": " + msg;
			super(str);
			this.line = line;
			this.col  = col;
		}
	}
})//*/
})(Req);